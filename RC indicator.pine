// Advanced Fair Value Gap (FVG) Indicator
// Designed for Gold Scalping on 15m and 5m timeframes
// Based on comprehensive FVG theory and market structure concepts

//@version=6
indicator("Advanced FVG Indicator", overlay=true, max_labels_count=500, max_boxes_count=500)

// User Inputs
timeframeInput = input.string("15", "Chart Timeframe", options=["1", "5", "15", "60", "240", "D"])
detectBISI = input.bool(true, "Detect Bullish FVGs (BISI)")
detectSIBI = input.bool(true, "Detect Bearish FVGs (SIBI)")
fvgMinGapSize = input.float(0.05, "Minimum Gap Size (%)", minval=0.01, step=0.01)
fvgMaxAge = input.int(50, "Maximum FVG Age (bars)", minval=1)
showMitigated = input.bool(false, "Show Mitigated FVGs")
extendFVG = input.bool(true, "Extend FVG Zones")
mtfAnalysis = input.bool(true, "Multi-Timeframe Analysis")
higherTF = input.string("60", "Higher Timeframe", options=["60", "240", "D", "W"])
showEntrySignals = input.bool(true, "Show Entry Signals")
entryStrategy = input.string("Sharp Turn", "Entry Strategy", options=["Sharp Turn", "Sharp Turn + Confirmation"])
riskManagement = input.bool(true, "Show Risk Management Levels")

// Color scheme
bullishFVGColor = color.new(color.green, 80)
bearishFVGColor = color.new(color.red, 80)
bullishFVGBorderColor = color.new(color.green, 20)
bearishFVGBorderColor = color.new(color.red, 20)
mitigatedAlpha = 90
perfectFVGColor = color.new(color.lime, 60)
breakawayFVGColor = color.new(color.blue, 60)
rejectionFVGColor = color.new(color.orange, 60)

// Structure to store FVG information
type FVG
    int start_idx
    int candle3_idx
    float top
    float bottom
    string fvgType // "BISI" or "SIBI"
    string fvgVariant // "Perfect", "Breakaway", "Rejection"
    bool mitigated
    string timeframe

var FVG[] bullishFVGs = array.new<FVG>()
var FVG[] bearishFVGs = array.new<FVG>()

// Function to detect FVGs in a given timeframe
detectFVGs(h, l, c, o, tf) =>
    var newBullishFVGs = array.new<FVG>()
    var newBearishFVGs = array.new<FVG>()
    
    // FVG detection logic
    for i = 2 to bar_index
        // Check for Bullish FVG (BISI)
        if detectBISI and l[i] > h[i-2]
            // Calculate gap size in percentage
            gapSize = (l[i] - h[i-2]) / h[i-2] * 100
            
            if gapSize >= fvgMinGapSize
                // Determine FVG variant
                variant = "Perfect" // Default
                
                // Check if it's a breakaway (3rd candle closes above 2nd candle high)
                if c[i] > h[i-1]
                    variant := "Breakaway"
                // Check if it's a rejection (3rd candle closes near its low)
                else if c[i] < l[i] + (h[i] - l[i]) * 0.3
                    variant := "Rejection"
                
                // Create FVG object
                newFVG = FVG.new()
                newFVG.start_idx := i-2
                newFVG.candle3_idx := i
                newFVG.top := l[i]
                newFVG.bottom := h[i-2]
                newFVG.fvgType := "BISI"
                newFVG.fvgVariant := variant
                newFVG.mitigated := false
                newFVG.timeframe := tf
                
                array.push(newBullishFVGs, newFVG)
        
        // Check for Bearish FVG (SIBI)
        if detectSIBI and h[i] < l[i-2]
            // Calculate gap size in percentage
            gapSize = (l[i-2] - h[i]) / l[i-2] * 100
            
            if gapSize >= fvgMinGapSize
                // Determine FVG variant
                variant = "Perfect" // Default
                
                // Check if it's a breakaway (3rd candle closes below 2nd candle low)
                if c[i] < l[i-1]
                    variant := "Breakaway"
                // Check if it's a rejection (3rd candle closes near its high)
                else if c[i] > h[i] - (h[i] - l[i]) * 0.3
                    variant := "Rejection"
                
                // Create FVG object
                newFVG = FVG.new()
                newFVG.start_idx := i-2
                newFVG.candle3_idx := i
                newFVG.top := l[i-2]
                newFVG.bottom := h[i]
                newFVG.fvgType := "SIBI"
                newFVG.fvgVariant := variant
                newFVG.mitigated := false
                newFVG.timeframe := tf
                
                array.push(newBearishFVGs, newFVG)
    
    [newBullishFVGs, newBearishFVGs]

// Get current timeframe data
[bullish, bearish] = detectFVGs(high, low, close, open, timeframeInput)

// Process higher timeframe data if enabled
if mtfAnalysis
    request.security(syminfo.tickerid, higherTF, detectFVGs(high, low, close, open, higherTF))

// Check for FVG mitigation and cleanup old FVGs
processAndCleanFVGs() =>
    // Process bullish FVGs
    for i = array.size(bullishFVGs) - 1 to 0 by -1
        fvg = array.get(bullishFVGs, i)
        
        // Check if FVG is too old
        if bar_index - fvg.start_idx > fvgMaxAge
            array.remove(bullishFVGs, i)
            continue
        
        // Check if FVG is mitigated (price traded into the gap)
        if not fvg.mitigated and low <= fvg.top and low >= fvg.bottom
            fvg.mitigated := true
            if not showMitigated
                array.remove(bullishFVGs, i)
    
    // Process bearish FVGs
    for i = array.size(bearishFVGs) - 1 to 0 by -1
        fvg = array.get(bearishFVGs, i)
        
        // Check if FVG is too old
        if bar_index - fvg.start_idx > fvgMaxAge
            array.remove(bearishFVGs, i)
            continue
        
        // Check if FVG is mitigated (price traded into the gap)
        if not fvg.mitigated and high >= fvg.bottom and high <= fvg.top
            fvg.mitigated := true
            if not showMitigated
                array.remove(bearishFVGs, i)

// Add new FVGs to our collections
addNewFVGs() =>
    for i = 0 to array.size(bullish) - 1
        array.push(bullishFVGs, array.get(bullish, i))
    
    for i = 0 to array.size(bearish) - 1
        array.push(bearishFVGs, array.get(bearish, i))

// Draw FVG zones on chart
drawFVGs() =>
    // Draw bullish FVGs
    for i = 0 to array.size(bullishFVGs) - 1
        fvg = array.get(bullishFVGs, i)
        
        // Determine box color based on FVG variant and mitigation status
        fvgColor = bullishFVGColor
        borderColor = bullishFVGBorderColor
        
        if fvg.fvgVariant == "Perfect"
            fvgColor := color.new(perfectFVGColor, fvg.mitigated ? mitigatedAlpha : 60)
        else if fvg.fvgVariant == "Breakaway"
            fvgColor := color.new(breakawayFVGColor, fvg.mitigated ? mitigatedAlpha : 60)
        else if fvg.fvgVariant == "Rejection"
            fvgColor := color.new(rejectionFVGColor, fvg.mitigated ? mitigatedAlpha : 60)
        
        if fvg.mitigated
            borderColor := color.new(borderColor, mitigatedAlpha)
        
        // Draw FVG box
        box.new(fvg.start_idx, fvg.top, extendFVG ? bar_index : fvg.candle3_idx, fvg.bottom, bgcolor=fvgColor, border_color=borderColor, border_width=1)
        
        // Add label for higher timeframe FVGs
        if fvg.timeframe != timeframeInput
            label.new(fvg.start_idx, fvg.top, fvg.timeframe + "\n" + fvg.fvgVariant, label.style_label_down, color.new(perfectFVGColor, 80), color.white, size.tiny)
    
    // Draw bearish FVGs
    for i = 0 to array.size(bearishFVGs) - 1
        fvg = array.get(bearishFVGs, i)
        
        // Determine box color based on FVG variant and mitigation status
        fvgColor = bearishFVGColor
        borderColor = bearishFVGBorderColor
        
        if fvg.fvgVariant == "Perfect"
            fvgColor := color.new(perfectFVGColor, fvg.mitigated ? mitigatedAlpha : 60)
        else if fvg.fvgVariant == "Breakaway"
            fvgColor := color.new(breakawayFVGColor, fvg.mitigated ? mitigatedAlpha : 60)
        else if fvg.fvgVariant == "Rejection"
            fvgColor := color.new(rejectionFVGColor, fvg.mitigated ? mitigatedAlpha : 60)
        
        if fvg.mitigated
            borderColor := color.new(borderColor, mitigatedAlpha)
        
        // Draw FVG box
        box.new(fvg.start_idx, fvg.top, extendFVG ? bar_index : fvg.candle3_idx, fvg.bottom, bgcolor=fvgColor, border_color=borderColor, border_width=1)
        
        // Add label for higher timeframe FVGs
        if fvg.timeframe != timeframeInput
            label.new(fvg.start_idx, fvg.bottom, fvg.timeframe + "\n" + fvg.fvgVariant, label.style_label_up, color.new(perfectFVGColor, 80), color.white, size.tiny)

// Generate entry signals
generateEntrySignals() =>
    var bullishEntries = array.new<int>(0)
    var bearishEntries = array.new<int>(0).new<int>(0).new<int>(0)
    
    if not showEntrySignals
        return [bullishEntries, bearishEntries]
    
    // Find Perfect FVGs for potential entries
    for i = 0 to array.size(bullishFVGs) - 1
        fvg = array.get(bullishFVGs, i)
        
        // For Sharp Turn strategy, we're looking for Perfect FVGs
        if fvg.fvgVariant == "Perfect" and not fvg.mitigated
            // Price is approaching the FVG
            if low <= fvg.top + (fvg.top - fvg.bottom) * 0.1 and close > open
                array.push(bullishEntries, bar_index)
                break
        
        // For Breakaway FVGs, enter on the 3rd candle close
        if fvg.fvgVariant == "Breakaway" and bar_index == fvg.candle3_idx and entryStrategy == "Sharp Turn"
            array.push(bullishEntries, bar_index)
            break
    
    // Find Perfect FVGs for potential entries
    for i = 0 to array.size(bearishFVGs) - 1
        fvg = array.get(bearishFVGs, i)
        
        // For Sharp Turn strategy, we're looking for Perfect FVGs
        if fvg.fvgVariant == "Perfect" and not fvg.mitigated
            // Price is approaching the FVG
            if high >= fvg.bottom - (fvg.top - fvg.bottom) * 0.1 and close < open
                array.push(bearishEntries, bar_index)
                break
        
        // For Breakaway FVGs, enter on the 3rd candle close
        if fvg.fvgVariant == "Breakaway" and bar_index == fvg.candle3_idx and entryStrategy == "Sharp Turn"
            array.push(bearishEntries, bar_index)
            break
    
    // For Sharp Turn + Confirmation, we need additional confirmation
    if entryStrategy == "Sharp Turn + Confirmation"
        // Add confirmation logic here
        // For example, check if a lower timeframe has also created an FVG in same direction
        // This would be implemented with request.security for lower timeframe data
    
    [bullishEntries, bearishEntries]

// Draw entry signals
drawEntrySignals(bullishEntries, bearishEntries) =>
    for i = 0 to array.size(bullishEntries) - 1
        entryBar = array.get(bullishEntries, i)
        if entryBar == bar_index
            label.new(bar_index, low - syminfo.mintick * 10, "BUY", label.style_label_up, color.green, color.white, size.normal)
    
    for i = 0 to array.size(bearishEntries) - 1
        entryBar = array.get(bearishEntries, i)
        if entryBar == bar_index
            label.new(bar_index, high + syminfo.mintick * 10, "SELL", label.style_label_down, color.red, color.white, size.normal)

// Process market structure to determine trend
determineMarketStructure() =>
    var pivotHigh = high
    var pivotLow = low
    var structureTrend = "neutral"
    
    // Bullish structure when we make higher highs and higher lows
    if high > pivotHigh and low > pivotLow
        structureTrend := "bullish"
        pivotHigh := high
        pivotLow := low
    
    // Bearish structure when we make lower highs and lower lows
    if high < pivotHigh and low < pivotLow
        structureTrend := "bearish"
        pivotHigh := high
        pivotLow := low
    
    structureTrend

// Execute the strategy
addNewFVGs()
processAndCleanFVGs()
drawFVGs()

// Implement market structure and flow analysis
structure = determineMarketStructure()

// Generate and draw entry signals
[bullEntries, bearEntries] = generateEntrySignals()
drawEntrySignals(bullEntries, bearEntries)

// Draw risk management levels if enabled
if riskManagement
    // For each entry, we can calculate appropriate stop-loss and take-profit levels
    // This is more complex and would depend on the specific FVG and strategy being used
    // Implement this based on the specific risk management approach you want to use

// Display information in status line
var statusText = ""
if array.size(bullishFVGs) > 0 or array.size(bearishFVGs) > 0
    bisiCount = 0
    sibiCount = 0
    
    for i = 0 to array.size(bullishFVGs) - 1
        if not array.get(bullishFVGs, i).mitigated
            bisiCount += 1
    
    for i = 0 to array.size(bearishFVGs) - 1
        if not array.get(bearishFVGs, i).mitigated
            sibiCount += 1
    
    statusText := "Unmitigated FVGs - BISI: " + str.tostring(bisiCount) + " | SIBI: " + str.tostring(sibiCount) + " | Market Structure: " + structure
    
    // If the last bar has an entry signal, append that information
    if array.size(bullEntries) > 0 and array.get(bullEntries, array.size(bullEntries) - 1) == bar_index
        statusText := statusText + " | BULLISH ENTRY SIGNAL"
    if array.size(bearEntries) > 0 and array.get(bearEntries, array.size(bearEntries) - 1) == bar_index
        statusText := statusText + " | BEARISH ENTRY SIGNAL"

table.new(position.top_right, 1, 1, bgcolor=color.new(color.black, 70), border_width=1)
table.cell(table.new(position.top_right, 1, 1), 0, 0, statusText, text_color=color.white, bgcolor=color.new(color.blue, 70))